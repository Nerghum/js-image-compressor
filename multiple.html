<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Image Compressor</title>
</head>
<body>
  <h1>Image Compressor</h1>

  <input type="file" accept="image/*" id="imageInput" multiple />
  <button id="downloadAllBtn" disabled style="margin-left:10px;">Download All</button>

  <br /><br />
  <div id="imageContainer"></div>

  <script>
    // Settings
    const MAX_WIDTH = 2600;      // resize down if wider than this
    const JPEG_QUALITY = 0.7;    // 0..1

    // Keep compressed outputs here for "Download All"
    const compressedOutputs = []; // { filename, blobUrl }

    const imageInput = document.getElementById("imageInput");
    const imageContainer = document.getElementById("imageContainer");
    const downloadAllBtn = document.getElementById("downloadAllBtn");

    imageInput.addEventListener("change", async (e) => {
      const files = Array.from(e.target.files || []);
      imageContainer.innerHTML = "";
      compressedOutputs.length = 0;
      downloadAllBtn.disabled = true;

      if (!files.length) return;

      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const index = i + 1;

        // UI container
        const imageDiv = document.createElement("div");
        imageDiv.className = "image-div";
        imageDiv.innerHTML = `<div class="label">#${index} - ${escapeHtml(file.name)}</div>`;
        imageContainer.appendChild(imageDiv);

        // Show original preview (object URL)
        const originalUrl = URL.createObjectURL(file);
        const originalImgEl = document.createElement("img");
        originalImgEl.src = originalUrl;
        originalImgEl.alt = `Original Image ${index}`;
        originalImgEl.className = "preview";
        imageDiv.appendChild(originalImgEl);

        // Compress + resize
        try {
          const { blob, width, height } = await compressAndResize(file, MAX_WIDTH, JPEG_QUALITY);

          // Make a blob URL for preview + download
          const blobUrl = URL.createObjectURL(blob);

          // Show compressed preview
          const compressedImgEl = document.createElement("img");
          compressedImgEl.src = blobUrl;
          compressedImgEl.alt = `Compressed Image ${index}`;
          compressedImgEl.className = "preview";
          imageDiv.appendChild(compressedImgEl);

          // Info
          const info = document.createElement("div");
          info.className = "info";
          info.textContent = `Output: ${width}Ã—${height} | ${(blob.size / 1024).toFixed(1)} KB`;
          imageDiv.appendChild(info);

          // Single download link
          const downloadLink = document.createElement("a");
          downloadLink.href = blobUrl;

          const baseName = file.name.replace(/\.[^/.]+$/, "") || `image_${index}`;
          const outName = `${baseName}_compressed.jpg`;

          downloadLink.download = outName;
          downloadLink.textContent = `Download Compressed Image ${index}`;
          downloadLink.className = "download-link";
          imageDiv.appendChild(downloadLink);

          // Save for "Download All"
          compressedOutputs.push({ filename: outName, blobUrl });

          // Enable download all once we have at least 1 output
          downloadAllBtn.disabled = compressedOutputs.length === 0;

          // Cleanup original preview URL when image loaded
          originalImgEl.onload = () => URL.revokeObjectURL(originalUrl);
        } catch (err) {
          const errorEl = document.createElement("div");
          errorEl.className = "error";
          errorEl.textContent = `Failed to process ${file.name}: ${err?.message || err}`;
          imageDiv.appendChild(errorEl);
          URL.revokeObjectURL(originalUrl);
        }
      }
    });

    downloadAllBtn.addEventListener("click", async () => {
      if (!compressedOutputs.length) return;

      // Trigger individual downloads with a slight delay (more reliable in browsers)
      // Note: Some browsers may still show a "multiple downloads" permission prompt.
      for (let i = 0; i < compressedOutputs.length; i++) {
        const { filename, blobUrl } = compressedOutputs[i];
        triggerDownload(blobUrl, filename);
        await sleep(150);
      }
    });

    function triggerDownload(url, filename) {
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    function sleep(ms) {
      return new Promise((r) => setTimeout(r, ms));
    }

    async function compressAndResize(file, maxWidth, quality) {
      // Decode image using createImageBitmap if available (fast & memory-friendly)
      const bitmap = await fileToBitmap(file);

      // Compute new size (only shrink if wider than maxWidth)
      const scale = bitmap.width > maxWidth ? (maxWidth / bitmap.width) : 1;
      const targetW = Math.round(bitmap.width * scale);
      const targetH = Math.round(bitmap.height * scale);

      // Canvas
      const canvas = document.createElement("canvas");
      canvas.width = targetW;
      canvas.height = targetH;
      const ctx = canvas.getContext("2d");

      // Better downscaling quality
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";

      // Draw resized
      ctx.drawImage(bitmap, 0, 0, targetW, targetH);

      // Export JPEG blob
      const blob = await canvasToBlob(canvas, "image/jpeg", quality);

      // If bitmap is ImageBitmap, close it to release memory
      if (bitmap && typeof bitmap.close === "function") bitmap.close();

      return { blob, width: targetW, height: targetH };
    }

    async function fileToBitmap(file) {
      // Prefer createImageBitmap
      if ("createImageBitmap" in window) {
        return await createImageBitmap(file);
      }

      // Fallback: HTMLImageElement decode
      const dataUrl = await readFileAsDataURL(file);
      const img = new Image();
      img.src = dataUrl;
      await img.decode();
      return img;
    }

    function canvasToBlob(canvas, type, quality) {
      return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) return reject(new Error("Canvas export failed."));
          resolve(blob);
        }, type, quality);
      });
    }

    function readFileAsDataURL(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error || new Error("File read failed."));
        reader.readAsDataURL(file);
      });
    }

    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, (m) => ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#039;",
      }[m]));
    }
  </script>

  <style>
    body {
      font-family: Arial, sans-serif;
    }
    .image-div {
      margin-bottom: 20px;
      padding: 12px;
      border: 1px solid #ccc;
      border-radius: 8px;
    }
    .label {
      font-weight: 600;
      margin-bottom: 10px;
    }
    .preview {
      max-width: 48%;
      margin-left: 10px;
      vertical-align: top;
      border-radius: 6px;
    }
    .info {
      margin-top: 10px;
      font-size: 13px;
      opacity: 0.85;
    }
    .download-link {
      display: inline-block;
      margin-top: 10px;
    }
    .error {
      margin-top: 10px;
      color: #b00020;
      font-size: 13px;
    }
  </style>
</body>
</html>
